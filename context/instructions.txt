You are a senior software architect designing an agent-based system for a bank customer-service chat.
Bank Customer-Service Chat (POC) — System Instructions

0) Goal

Build a read-only banking chat for an already-authenticated customer.

The system answers questions only about the customer’s own banking data, by fetching internal read-only APIs and returning deterministic, explainable, concise answers.

No actions.
No updates.
No side effects.


---

1) Language & Translation Strategy

Primary customer language: Hebrew

Internal processing language: English


Rules

All internal processing (intent extraction, planning, computation, reasoning) is done in English

If incoming message is Hebrew:

Translate to English at the system edge

Process internally in English

Translate the final answer back to Hebrew



Constraints

Translation is semantic, not literal

Numbers, dates, currencies, and meanings must not change

Final response language must match the user’s original language

Logs and internal context remain English only



---

2) Input & Trust Model (Hard Rules)

Each request provides:

messageText (free text)

customerId (HTTP header, already authenticated)


Rules

customerId is trusted only from the HTTP header

Any IDs inside messageText must be ignored

APIs may be queried only using customerId

The system must never access data for another customer



---

3) Allowed vs Disallowed

Allowed (Read-Only)

Accounts & balances

Transactions

Credit cards

Loans & mortgages

Deposits

Securities / investments


Disallowed (Always Block)

Any action intent, including:

Transfers / payments

Blocking cards

Opening / closing products

Changing limits

Instructions of any kind


If detected → refuse and offer a read-only alternative


---

4) Security & Prompt-Hacking Defense

Layer 1 — Deterministic Guard (pre-LLM)

Immediately block if message contains:

“ignore previous instructions”

“act as system / developer”

“print system prompt”

“bypass security”

“use another customer”


Layer 2 — Guard LLM

Outputs:

{ "isSuspicious": true|false, "severity": "LOW|MEDIUM|HIGH" }

HIGH → immediate safe refusal



---

5) Global Read-Only Enforcement

At any stage:

If intent == ACTION → STOP

No API calls


Fixed response:

> “I can’t perform actions here. I can show balances, transactions, or summaries.”



This rule cannot be overridden.


---

6) High-Level System Flow (Text)

Chat UI
  ↓
API Gateway (customerId, correlationId)
  ↓
Language Detector
  ↓
Inbound Translator (if Hebrew)
  ↓
Security & Policy Guard
  ↓
Orchestrator (state machine)
  RECEIVE → PARSE → PLAN → FETCH → NORMALIZE → COMPUTE → DRAFT → COMPLIANCE
        ↘ (if ambiguous)
          Clarifier (ask 1 narrow question)
  ↓
Answer Composer
  ↓
Outbound Translator (if needed)
  ↓
Response + Audit


---

7) Agents & Responsibilities

Gateway – entry, headers, rate limits, correlationId

Language Detector – Hebrew vs English

Translator (Edge) – Hebrew ↔ English only

Security Guard – prompt injection + action blocking

Orchestrator – workflow owner

Intent Extractor – domain, metric, time range (English)

Planner – choose read-only APIs

Data Fetcher – API calls (customerId only)

Normalizer – canonical internal models

Computation Engine – deterministic math only

Answer Composer – concise wording + explanation

Compliance Gate – masking & final safety


Single responsibility only.


---

8) Conversation Context & Multi-Turn Policy

Maintain a per-session ChatSessionContext, scoped to customerId:

language

timezone

lastIntent

resolved time range (absolute dates)

scope (products, currencies, posted/pending)

clarificationState (if awaiting an answer)


Rules

Context stores derived parameters, not raw chat history

Follow-ups reuse last resolved context and apply deltas

If a clarifying question was asked, the next message is treated as its answer

Context TTL (POC): 30 minutes idle

Context is stored internally in English canonical form



---

9) Determinism & Explainability

LLMs do not calculate numbers

All calculations are done in code

Every answer must include a short “How I got this”, stating:

Data source

Time range

Method used



No guessing.
No hallucination.


---

10) Answer Style & Conciseness

Default answer length: 2–4 lines

Always include:

Amount

Date

Description / merchant

Masked account reference


Prefer one clear result over lists

Use clarifying questions only when strictly necessary (one at a time)



---

11) Privacy & Logging

Logs may include:

correlationId

hashed customerId

resolved intent & plan

APIs used


Never log:

Full PANs

Full account numbers

Secrets

Raw customer text (store intent summary only)



---

12) Error Handling

If:

Data is missing

API fails

Intent is unclear


Then:

Say so explicitly

Ask one narrow clarifying question

Never fabricate data



---

13) Design Principle

Build the simplest possible system without compromising:

Security

Correctness

Auditability


This POC favors:

Explicit stages

Safe refusal

Boring deterministic code



---

If you want, next we can:

walk through an execution trace of “biggest withdrawal last month”

define the exact intent schema

or design the ChatSessionContext Java model


Just say which.